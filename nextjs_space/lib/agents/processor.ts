
import { db } from '@/db';
import {
  scheduledAgentsTable,
  scheduledAgentJobsTable,
  scheduledAgentLogsTable,
  signalsTable,
} from '@/db/schema';
import { eq } from 'drizzle-orm';
import { fetchKrakenOHLCByTimeframe } from '@/lib/api/kraken';
import { SignalGenerator } from '@/lib/analysis/signal-generator';
import { sendSignalAlert } from '@/lib/alerts/service';

type JobRecord = {
  id: string;
  agent_id: string;
  attempts: number;
  run_context?: any;
};

export async function runAgentJob(job: JobRecord) {
  const [agent] = await db
    .select()
    .from(scheduledAgentsTable)
    .where(eq(scheduledAgentsTable.id, job.agent_id));

  if (!agent) throw new Error('Agent not found');

  const start = Date.now();

  const log = async (
    level: 'info' | 'warn' | 'error' | 'debug',
    message: string,
    context?: any
  ) =>
    db.insert(scheduledAgentLogsTable).values({
      agentId: agent.id,
      jobId: job.id,
      level,
      message,
      context: context as any,
    });

  await log('info', 'Job started', { trigger: job.run_context?.trigger || 'schedule' });

  const results: any[] = [];

  // Map intervalMinutes to timeframe string
  const timeframeMap: Record<number, string> = {
    1: '1m',
    5: '5m',
    15: '15m',
    30: '30m',
    60: '1h',
    240: '4h',
    1440: '1d',
  };

  const timeframe = timeframeMap[agent.intervalMinutes] || '1h';

  // Fetch data per pair
  for (const pair of agent.pairs) {
    try {
      await log('info', `Processing pair: ${pair}`);

      // Fetch OHLC data from Kraken
      const ohlcResponse = await fetchKrakenOHLCByTimeframe(pair, timeframe);

      if (!ohlcResponse.success || !ohlcResponse.data || ohlcResponse.data.length === 0) {
        await log('warn', 'No OHLC data returned', { pair, error: ohlcResponse.error });
        continue;
      }

      const ohlcData = ohlcResponse.data;

      // Process each strategy
      const strategies = agent.strategies as any[];
      for (const strategy of strategies) {
        try {
          const generator = new SignalGenerator(ohlcData, {
            strategy: strategy.id,
            confidenceThreshold: agent.minConfidence || 60,
          });

          const signal = generator.generateSignal();

          if (signal && signal.confidence >= (agent.minConfidence || 60)) {
            // Save signal to database
            const [newSignal] = await db.insert(signalsTable).values({
              watchlistItemId: null,
              krakenPair: pair,
              altname: pair,
              direction: signal.direction as 'buy' | 'sell',
              timeframe: timeframe as any,
              strategy: strategy.id,
              entryPrice: signal.entryPrice.toString(),
              stopLoss: signal.stopLoss?.toString() || null,
              takeProfit: signal.takeProfit?.toString() || null,
              confidence: signal.confidence.toString(),
              risk: signal.risk,
              status: 'active',
              indicators: signal.indicators as any,
              reason: signal.reason || `Generated by agent: ${agent.name}`,
            }).returning();

            results.push(signal);
            await log('info', `Signal generated for ${pair}`, {
              strategy: strategy.id,
              direction: signal.direction,
              confidence: signal.confidence,
            });

            // Send alert notification for new signal
            try {
              await sendSignalAlert({
                userId: agent.userId,
                signal: newSignal,
              });
              await log('info', `Alert sent for signal ${newSignal.id}`);
            } catch (alertError: any) {
              await log('warn', 'Failed to send alert', {
                signalId: newSignal.id,
                error: alertError?.message,
              });
            }
          }
        } catch (e: any) {
          await log('warn', 'Strategy processing failed', {
            pair,
            strategy: strategy.id,
            error: e?.message,
          });
        }
      }
    } catch (e: any) {
      await log('warn', 'Pair processing failed', { pair, error: e?.message });
      continue;
    }
  }

  // Mark job success
  await db
    .update(scheduledAgentJobsTable)
    .set({
      status: 'succeeded',
      finishedAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(scheduledAgentJobsTable.id, job.id));

  // Update agent last/next run
  const now = new Date();
  await db
    .update(scheduledAgentsTable)
    .set({
      lastRunAt: now,
      nextRunAt: new Date(now.getTime() + agent.intervalMinutes * 60_000),
      updatedAt: now,
    })
    .where(eq(scheduledAgentsTable.id, agent.id));

  await log('info', 'Job completed', {
    durationMs: Date.now() - start,
    signalsSaved: results.length,
  });
}
